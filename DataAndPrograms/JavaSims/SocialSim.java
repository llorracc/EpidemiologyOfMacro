/** * @author Jason Harburger * jasonharburger@hotmail.com *  * 10/19/01 *  */import java.util.Random;import java.math.*;import java.io.*;import java.util.StringTokenizer;import java.util.Vector;								public class SocialSim{	//generates random numbers  	private static Random rand = new Random();		//POPULATION VARIABLES	public int gridSize; 	public int iterations=100;	public Agent[][] pop;	public Storage[] simulatedStats;	public int timestep=0;                         //keeps track of time		public float PublicNewsForecast=(float) 2.09;  //keeps track of current PublicNewsForecast rate		//if data is inputted then each iteration's PublicNewsForecast	//rate is not random but based on historical, user-supplied data	public boolean inputForecastHistory;	//NOTE: inputted data must be in format of having	//no column names and two columns (one for time and the other for PublicNewsForecast		public boolean CommonSourceUpdating;  //determines if updating from common news source occurs	public float lambdaMinSS;	public float lambdaMaxSS;	public float NewsAgentProb;           //probability of a given agent being a news source	public float NeighborUpdateProb;      //probability of updating from your neighbor	public float RandomMixingProb = 0;    //probability of updating by bumping into random population member	public float errorStdDev;             //standard deviation of the Gaussian error to add to infl expectations	public String inputFileName  = "input.txt";	public String outputFileName = "output.txt";		Vector ForecastHistory;		public SocialSim(String inputFileNameInput, int gridSizeInput		, double lambdaMinInput, double lambdaMaxInput		, double NewsAgentProbInput		, double NeighborUpdateProbInput		, double RandomMixingProbInput		, double errorStdDevInput		, String outputFileNameInput){					System.out.println("Working on SocialSim with parameters:" + inputFileNameInput		+","+  gridSizeInput		+","+  lambdaMinInput		+","+  lambdaMaxInput		+","+  NewsAgentProbInput		+","+  NeighborUpdateProbInput		+","+  RandomMixingProbInput		+","+  outputFileNameInput);		System.out.println("Trying to create variables.");		System.out.flush();				gridSize           = gridSizeInput;		lambdaMinSS        = (float) lambdaMinInput;		lambdaMaxSS        = (float) lambdaMaxInput;		NewsAgentProb      = (float) NewsAgentProbInput;		NeighborUpdateProb = (float) NeighborUpdateProbInput;		RandomMixingProb   = (float) RandomMixingProbInput;		errorStdDev        = (float) errorStdDevInput;		inputFileName      = inputFileNameInput;		outputFileName     = outputFileNameInput;				System.out.println("Variables Created.");		if (inputFileNameInput.length() > 0) inputForecastHistory=true;		else inputForecastHistory=false;			//create the agent population		pop=initializePop();		simulatedStats=initializeStorage();					if (NewsAgentProbInput > 0) {						//calculate DistanceToNearestNewsSource between agents and closest news source			for (int k=0;k<gridSize;k++)				for(int l=0; l<gridSize; l++)	{								pop[k][l].setDist(calcDistance(k,l));			}						//find best neighbor for providing news			for (int k=0;k<gridSize;k++)				for(int l=0; l<gridSize; l++)	{								pop[k][l].setBuddy(findBuddy(k,l));			}					} // End if (NewsAgentProbInput>0) 				run();						} // end public SocialSim		/** Conducts simulation.	 */    public void run() {		    		if (inputForecastHistory){			ForecastHistory=(new IO()).readData(inputFileName);			iterations=ForecastHistory.size();			simulatedStats=initializeStorage();		}						//timestep and update agents		for(int TimeStep=0;TimeStep<iterations;TimeStep++){								if(inputForecastHistory==true){								Inputted thisTimeStepData=(Inputted) ForecastHistory.elementAt(TimeStep);				PublicNewsForecast=thisTimeStepData.inf;			}			else				PublicNewsForecast=generateInflation();						//get updates from neighbors and store in a 			//temporary array so that updates aren't			//dependent on agent position in each round			Agent[][] temp=new Agent[gridSize][gridSize];						if (NewsAgentProb > 0) {			for (int k=0;k<gridSize;k++)				for(int l=0; l<gridSize; l++){					temp[k][l]=pop[k][l];				  	if (pop[k][l].getsNews == true) {temp[k][l].InflationExpectation = PublicNewsForecast;}				    else {									float NeighborUpdateDraw = rand.nextFloat();					if (NeighborUpdateDraw <= NeighborUpdateProb) {						int neighbor_xcoord=pop[k][l].buddy_locale[0];						int neighbor_ycoord=pop[k][l].buddy_locale[1];						float NeighborNews=pop[neighbor_xcoord][neighbor_ycoord].InflationExpectation;						temp[k][l].updateFromNeighbor(TimeStep,PublicNewsForecast,NeighborNews+makeError(NeighborNews, errorStdDev));						}					}		        }//close for		    		    //finished spreading the news, so put new data back into population	    			    pop = temp;			}  //end if(NewsAgentProb ...									//now allow people to randomly mix with each other; someone with newer info infects someone with older			for (int k=0;k<gridSize;k++)				for(int l=0; l<gridSize; l++) {					float RandomMixingDraw = rand.nextFloat();					if (RandomMixingDraw < RandomMixingProb/2) {       // Then interact this person with someone else random (2 interactions)						int iRandom = (int) rand.nextFloat()*gridSize; // Draw integers between 0 and gridSize-1						int jRandom = (int) rand.nextFloat()*gridSize; // In principle, allows interaction with self						// System.out.println("Shouldn't be here!");												if (pop[iRandom][jRandom].TimeOfLastUpdate > pop[k][l].TimeOfLastUpdate) {							pop[k][l].TimeOfLastUpdate     = pop[iRandom][jRandom].TimeOfLastUpdate;							pop[k][l].InflationExpectation = pop[iRandom][jRandom].InflationExpectation+makeError(pop[iRandom][jRandom].InflationExpectation,errorStdDev);							} 						else {							pop[iRandom][jRandom].TimeOfLastUpdate     = pop[k][l].TimeOfLastUpdate;							pop[iRandom][jRandom].InflationExpectation = pop[k][l].InflationExpectation+makeError(pop[k][l].InflationExpectation,errorStdDev);						} // end else					} // end if(pop ...				} // end for(int l=0 ...						//get updates from external news update (lambda)				for (int k=0;k<gridSize;k++)					for(int l=0; l<gridSize; l++){						if (rand.nextFloat() < pop[k][l].CommonUpdateProb){											pop[k][l].updateCommon(TimeStep,PublicNewsForecast+makeError(PublicNewsForecast,errorStdDev));							};				    	    }//close for		 			//store this iteration's data			float popMeanForecast=getMeanInflExp();            //store this period's mean into next period's old            simulatedStats[TimeStep].setMeanInflExp(getMeanInflExp());			simulatedStats[TimeStep].setPublicNewsForecast(PublicNewsForecast);			simulatedStats[TimeStep].setFractionUpdating(getFractionUpdating());            			//if we're dealing with inputted data            //make sure time steps have same designation            //as data            if(inputForecastHistory==true)    			simulatedStats[TimeStep].setRun(((Inputted) ForecastHistory.elementAt(TimeStep)).time_desc);            else                simulatedStats[TimeStep].setRun(TimeStep);			simulatedStats[TimeStep].setSdev(findSdev(popMeanForecast));		} // end timestep		(new IO()).save(simulatedStats, lambdaMinSS, lambdaMaxSS, outputFileName);		}			/**sets getsNews values for array of	 * Agents[][]	 * 	 * @return pop returns the new array	 */	public Agent[][] initializePop(){		Agent[][] p=new Agent[gridSize][gridSize];		//move across each row		for (int i=0;i<gridSize;i++){					//move down each row			for(int j=0; j<gridSize; j++){								//randomly assign values				p[i][j]=new Agent(lambdaMinSS, lambdaMaxSS);				double NewsAgentDraw = rand.nextFloat();				if (NewsAgentDraw <= NewsAgentProb) p[i][j].getsNews = true;				if (NewsAgentDraw >  NewsAgentProb) p[i][j].getsNews = false;					//	System.out.println("NewsAgent:"+p[i][j].getsNews);			}//close for		}//close for						return p;	}    		public Storage[] initializeStorage(){		Storage[] f=new Storage[iterations];		//move across each row		for (int TimeStep=0;TimeStep<iterations;TimeStep++){			f[TimeStep]=new Storage();						}//close for				return f;	}    		public int wrap(int j) {		if (j >= 0) { return(j%gridSize);} else { return(j+gridSize); }	}		public int calcDistance(int x,int y){		int DistanceToNearestNewsSource=0;		int CountingUp = 0;				while (CountingUp < gridSize) {			for(int LoopOver=0;LoopOver<=2*CountingUp;LoopOver++) {				if (	(pop[wrap(x-CountingUp+LoopOver)][wrap(y-CountingUp)         ].getsNews == true)					||  (pop[wrap(x-CountingUp+LoopOver)][wrap(y+CountingUp)         ].getsNews == true)					||  (pop[wrap(x-CountingUp)         ][wrap(y-CountingUp+LoopOver)].getsNews == true)					||  (pop[wrap(x+CountingUp)         ][wrap(y-CountingUp+LoopOver)].getsNews == true)					) { DistanceToNearestNewsSource = CountingUp; CountingUp=gridSize+1; break; }					   // Found a news agent at this DistanceToNearestNewsSource; 					   // record the DistanceToNearestNewsSource then set while loop condition 					}  // end for loop clause				CountingUp++; // Failed to find a news agent, so increment			}      // end while loop				if (CountingUp == gridSize) { 			System.out.println("No news agents!"); 			BufferedReader console = new BufferedReader(new InputStreamReader(System.in));			try { String garbage = console.readLine();} catch (IOException e) {}			} // End if (CountingUp ...				//System.out.println("Distance: "+DistanceToNearestNewsSource);		return(DistanceToNearestNewsSource);	} // end of calcDistance							/**Method searches neighbors to find	* neighbor that is closer to news source and 	* will be the one who can give updates to a 	* given agent who is farther away	* from a news source	*		*/	public int[] findBuddy(int x, int y){		int[] coords=new int[2];		coords[0]=x;		coords[1]=y;				int MyDistance = pop[x][y].DistanceToNearestNewsSource;		int CountEligibleNeighbors  = 0;		int DistanceForThisNeighbor = 0;		int WhichNeighborToPick     = 0;				//look at neighbor for info		// First count the number of neighbors who are closer than you are			for (int i=-1;i<=1;i++){				for (int j=-1;j<=1;j++){					if((i!=0)&&(j!=0)){						int xpos=wrap(x+i);						int ypos=wrap(y+j);											DistanceForThisNeighbor=pop[xpos][ypos].DistanceToNearestNewsSource;						if (DistanceForThisNeighbor < MyDistance) CountEligibleNeighbors++;											}//close if((i!=0)&&(j!=0)){															}//close inner for loop			}//close outer for loop			WhichNeighborToPick = 1+(int) ((rand.nextFloat()*CountEligibleNeighbors));						CountEligibleNeighbors=0;			for (int i=-1;i<=1;i++){				for (int j=-1;j<=1;j++){					if((i!=0)&&(j!=0)){						int xpos=wrap(x+i);						int ypos=wrap(y+j);																//find closer agent to news source						DistanceForThisNeighbor=pop[xpos][ypos].DistanceToNearestNewsSource;						if (DistanceForThisNeighbor < MyDistance) CountEligibleNeighbors++;						if (CountEligibleNeighbors==WhichNeighborToPick){coords[0]=xpos;coords[1]=ypos;}					}//close if((i!=0)) 				}//close inner for loop			}//close outer for loop		return coords;	}		//Generates current PublicNewsForecast rate	private float generateInflation(){		         		//generate random number in range (-.5,.5)		float randomnum=rand.nextFloat()/2;		//now decide if change should be positive or neg		//generate a random number between 0 and 9		int tempn=rand.nextInt(10);         		if (tempn<5)			randomnum=(-1)*randomnum;		PublicNewsForecast=PublicNewsForecast + randomnum;   		return PublicNewsForecast;	}//close method		/**Computes average value held by population	 * for expectation of PublicNewsForecast	 */	public float getMeanInflExp(){		float sum=0;		for (int i = 0; i < gridSize; i++)           for (int j=0; j<gridSize;j++)				sum += pop[i][j].InflationExpectation;		return sum/(gridSize*gridSize);	}	public float getFractionUpdating(){		float sum=0;		for (int i = 0; i < gridSize; i++)           for (int j=0; j<gridSize;j++)				sum += pop[i][j].updatedThisPeriod;		return sum/(gridSize*gridSize);	}		/**Computes standard deviation of values held by population	 * for expectation of PublicNewsForecast	 */	public float findSdev(float aver){		double sum=0;		for (int i = 0; i < gridSize; i++)           for (int j=0; j<gridSize;j++)				sum=sum+Math.pow((pop[i][j].InflationExpectation-aver),2);		double temp = Math.sqrt(sum/(gridSize*gridSize));		return (new Float(temp).floatValue());	}				public float makeError(float inputExpectation, float errorStdDev){		double inflErrorDraw=rand.nextGaussian();		return (new Double(errorStdDev*inflErrorDraw*inputExpectation)).floatValue();	}			    public static void main(String[] args) {     	//arguments entered by user    	//to start simulation		    	    	int GridSize = 100;            	double LamMin = 0.25;    	double LamMax = 0.25;    	double NewsAgent = 0.0;         // Probability that a given agent is a 'news agent' who is always up to date    	double NeighborUpdate = 1.0;    // Probability that you update from a neighbor in a given period		double RandomMixingUpdate = 0.0;// Probability of updating from a randomly selected member of the pop		double errorStdDev = 0.0;				System.out.println("About to start.");		System.out.flush();//			BufferedReader console = new BufferedReader(new InputStreamReader(System.in));//			try { String garbage = console.readLine();} catch (IOException e) {}		SocialSim si=			new SocialSim("input.txt",GridSize,LamMin,LamMax,NewsAgent,NeighborUpdate,RandomMixingUpdate,errorStdDev,"Com_2525");		si=	new SocialSim("input.txt",GridSize,0.00  ,0.50  ,NewsAgent,NeighborUpdate,RandomMixingUpdate,errorStdDev,"Com_0050");		si= new SocialSim("input.txt",GridSize,0.20  ,0.30  ,NewsAgent,NeighborUpdate,RandomMixingUpdate,errorStdDev,"Com_2030");		si=	new SocialSim("input.txt",GridSize,0.15  ,0.35  ,NewsAgent,NeighborUpdate,RandomMixingUpdate,errorStdDev,"Com_1535");		si= new SocialSim("input.txt",GridSize,0.25  ,0.25  ,NewsAgent,NeighborUpdate,RandomMixingUpdate,0.5        ,"Com_2525_Err0p5");		si= new SocialSim("input.txt",GridSize,LamMin,LamMax,NewsAgent,NeighborUpdate,0.25              ,errorStdDev,"Ran_2525_25");		si= new SocialSim("input.txt",GridSize,LamMin,LamMax,NewsAgent,NeighborUpdate,0.10              ,errorStdDev,"Ran_2525_10");		si= new SocialSim("input.txt",GridSize,0.00  ,0.00  ,0.25     ,NeighborUpdate,RandomMixingUpdate,errorStdDev,"Nbr_25");//			new SocialSim("input.txt",GridSize,0.00  ,0.00  ,0.25     ,NeighborUpdate,RandomMixingUpdate,0.5        ,"Nbr_25_Err0p5");		si= new SocialSim("input.txt",GridSize,0.00  ,0.00  ,0.15     ,NeighborUpdate,RandomMixingUpdate,errorStdDev,"Nbr_15");		System.out.println("Finished.");		System.out.flush();//			console = new BufferedReader(new InputStreamReader(System.in));//			try { String garbage = console.readLine();} catch (IOException e) {}	System.exit(1);    }}