end clear memorycal 1959 1 4allocate 2001:4open data complex_q.ratdata(for=rat)compute maketable = 1compute NeweyWestLags = 4set u = lhurset adu = u{-4}-uset umicup = michunmore     ; * People who expect more unemploymentset umicsm = michunsame     ; * People who expect unemp to remain the sameset umicdn = michunless     ; * People who expect less unemploymentset umicdk = michundk       ; * People who say they don't knowset uavg = (u{1}+u{2}+u{3}+u{4})/4* average unemployment rate over the last yearset uavg_tp4 = uavg{-4}set aduavg = uavg_tp4-uavg* annual change in unemployment ratesmpl 1978:1 2001:4set dumic = umicup-umicdn* Use a regression to convert the Michigan 'up/down' question into a quantitative predictionlinreg(robusterrors,lags=NeweyWestLags,damp=1) aduavg / aduavg_e# constant dumic* Coefficient overwhelmingly statistically significant* Adding umicsm has very small effect on R^2, and it is not stat sigset aduavgmic_p = aduavg-aduavg_e   ; * Predicted change in unemployment based on regressionset uavgmic_p   = uavg+aduavgmic_p  ; * Predicted level of the unemployment rate is current level plus changeset uavgspf = (uspfa_tp1+uspfa_tp2+uspfa_tp3+uspfa_tp4)/4set aduavgspf = uavgspf-uavgset aduavgspf = uavgspf-uavg* Now see whether SPF has any forecasting power when Mich data are included, and vice versalinreg(robusterrors,lags=NeweyWestLags,damp=1) aduavg# constant dumic{1} aduavgspf* Only a lag of mic would have been available to the forecasters* Michigan Forecast not significant once SPF forecast is taken into accountlinreg(robusterrors,lags=24,damp=1) aduavg# constant aduavgspfsmpl 1978:1 *linreg(robusterrors,damp=1,lags=NeweyWestLags) uavgmic_p# constanttest 1# 1# 0if maketable == 1  source(noecho) esteqn_unemp_start.pgm  source(noecho) esteqn_unemp_memo.pgm  change output screenend iflinreg uavgmic_p / uavgmic_p_e# uavgspf uavgmic_p{1}correlate(qstats) uavgmic_p_e* No evidence of serial correlationcompute beta1 = %beta(1)compute beta2 = %beta(2)compute durbin = %durbincompute seesq  = %seesqcompute tstats1 = %tstats(1)compute tstats2 = %tstats(2)compute stderrs1 = %stderrs(1)compute stderrs2 = %stderrs(2)compute rbarsq   = %rbarsqrestrict(create) 1 uavgmic_p_e# 1 2# 1 1 1* Test whether the restriction \lambda + (1-\lambda) to equal 1 can be rejected* Syntax: first card lists coefficients used in restriction*         second card indicates multiple of corresponding coefficient, followed by sum* It can't reject the restrictioncorrelate(qstats) uavgmic_p_e* No evidence of serial correlation in residualscompute siga1pa2eq1 = %SIGNIFtest 1# 1# 0.25if maketable == 1  change output fileio  source(noecho) esteqn_unemp_base_unrestr.pgm  source(noecho) esteqn_unemp_base_restr.pgm  change output screenend if * What if we allow a constant?linreg uavgmic_p / uavgmic_p_e# constant uavgspf uavgmic_p{1}test 1# 1# 0if maketable == 1  change output fileio  source(noecho) esteqn_unemp_const.pgm  change output screenend if correlate(qstats) uavgmic_p_e* Still no evidence of serial correlation* What if we allow lagged to enter?* Linearly:linreg uavgmic_p / uavgmic_p_e# uavgspf uavgmic_p{1} uavg{1} compute beta1 = %beta(1)compute beta2 = %beta(2)compute beta3 = %beta(3)compute durbin = %durbincompute seesq  = %seesqcompute tstats1 = %tstats(1)compute tstats2 = %tstats(2)compute tstats3 = %tstats(3)compute stderrs1 = %stderrs(1)compute stderrs2 = %stderrs(2)compute stderrs3 = %stderrs(3)compute rbarsq   = %rbarsq* See if we can require lambda1 + lambda2 + (1-lambda1+lambda2)  = 1restrict(create) 1# 1 2 3# 1 1 1 1* It's happy with the restrictioncorrelate(qstats) uavgmic_p_e* And again there's no evidence of serial correlation in the residualsif maketable == 1  change output fileio  source(noecho) esteqn_unemp_lag.pgm  change output screenend if * Unfortunately, however, lagged inflation was statistically significant* But it wants to be in there with a NEGATIVE coeff, but only because there's no constant term:linreg uavgmic_p / uavgmic_p_e# constant uavgspf uavgmic_p{1} uavg{1} correlate(qstats) uavgmic_p_etest 1# 4# 0if maketable == 1  change output fileio  source(noecho) esteqn_unemp_lagandconst.pgm  source(noecho) esteqn_unemp_end.pgm  change output screenend if 